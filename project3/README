
-------------------------------------------------------------------------------

Project3ï¼š

CHORD Distributed Hash Table.

This project is written by W. Li for CS 5700: Fundamentals of Computer Networking.

-------------------------------------------------------------------------------

Achieved functions:

1. DHT Peer
  Implement a dht-peer which interacts with other dht-peers to build a ring.
  Join
  Leave/Crash
  Lookup
  Print the ring.

2. SHA1 Implementation  Use SHA1 as the consistent hashing function. 
  Use IP addresses and port numbers as identiers for the nodes.

3. DHT Client
  (To be continued ...)

-------------------------------------------------------------------------------

My submission includes 8 files:

1. makefile
2. dht_peer.c
3. dht_peer.h
4. mylib.c
5. mylib.h
6. sha1.c
7. sha1.h
8. README

-------------------------------------------------------------------------------

How to run the program:

(On a local host, use different port to allocate different peers.)

1. make
2. Run root: ./dht_peer -m 1 -p 15074 -h localhost
3. Run peer: ./dht_peer -m 0 -p 15070 -h localhost -r 15074 -R localhost
              (In the prompt window, enter '1' to join the peer in the ring.)
4. Exit    : Press control + C

-------------------------------------------------------------------------------

Data definition:

An object of the PeerNode type defines the IP addresses, port numbers, and node IDs for the predecessor node, this node and the successor node.

typedef struct PeerNode {
        // predecessor peer
	unsigned int pre_IP;
	unsigned short pre_Port;
	unsigned short pre_ID;
    
        // this node
	unsigned int cur_IP;
	unsigned short cur_Port;
	unsigned short cur_ID;

	// successor peer
	unsigned int suc_IP;
	unsigned short suc_Port;
	unsigned short suc_ID;
	
} PeerNode;

-------------------------------------------------------------------------------

Message Types:

1. Join Request (to root)
Sender      : a new peer node
Receiver    : the root node
Format      : JOIN + new_IP + new_Port
Message size: 7 bytes.

2. Join Request (to peer)
Sender      : an existing peer node / root
Receiver    : another peer node
Format      : JOIN + new_IP + new_Port + new_ID
Message size: 9 bytes.

3. Join Reply:
Sender      : an existing peer node / root
Receiver    : new node
Format      : JOIN_REPLY + new_ID + suc_IP + suc_Port + suc_ID + pre_IP + pre_Port + pre_ID
Message size: 19 bytes.

4. Update:
Sender      : an existing peer node / root
Receiver    : an existing peer node / root
Format      : UPDATE_SUC / UPDATE_PRE + IP + Port + ID.
Message size: 9 bytes.

5. Crash:
Sender      : an existing peer node / root (first generated by the crash node's successor)
Receiver    : an existing peer node / root
Format      : CRASH + crash_ID + cur_IP + cur_Port + cur_ID
Message size: 11 bytes.

6. Repair (special case of Update):
Sender      : crash node's predecessor
Receiver    : crash node's successor
Format      : UPDATE_PRE + IP + Port + ID.
Message size: 9 bytes.

-------------------------------------------------------------------------------

Design Approach:

DHT Peer
1. Parse information from the command line.
2. Initialize a receiving socket to receive message from given local port.
   Get local IP address (in bytes) and Port number (in integer).
3. Initialize a mutex for thread programming.
4. Check running mode (input after '-m' on command line).
   If type = 0, run the peer mode, go to step 5;
   If type = 1, run the root mode, go to step 6.
5. Prompt to user, construct a PeerNode to store node information for this node.
   When user enter '1', send a JOIN request to the root.
   Running main process for the node.
6. Compute node ID by SHA1 for the root. 
   Construct a PeerNode to store node information for this root.
   Running main process for the root.

There are two threads in the main process either this node is a peer or a root.
Both root and peer run the same thread to ping it's predecessor node.

1. Peer process:

The peer process keeps receiving messages from other peers or root.

1) If receives a JOIN REPLY:
   Update own node ID, and predecessor's and successor's node information.

2) If receives an UPDATE:
   Update predecessor's or successor's node information.

3) If receives a JOIN:
   Detect whether the node who wants to join the ring is going to be my new successor. If yes, send JOIN REPLY to the new node, send an UPDATE to my successor, and update my successor as the new node; or else, pass on the JOIN to my successor.

4) If receives a CRASH:
   Detect whether the crash node is my successor. If yes, update my successor as the crash node's successor and send REPAIR message to notify it; or else, pass on the CRASH message to my successor.


2. Root process:

The root process keeps receiving messages from other peers.

1) If receives a JOIN:
   Retrieves the new node's IP, Port number, and accordingly computes its node ID.
   If there is only one node in the ring (i.e. the root), update root's predecessor and successor as the new node, and send JOIN REPLY to the new node.
   Else if there are 2 nodes in the ring, check the new node's position in the ring, send JOIN REPLY to the new node, send UPDATE to root's successor, and update root's node information.
   Else if there are at least 3 nodes in the ring, check whether the new node is root's new successor. If yes, send JOIN REPLY to the new node, send UPDATE to root's successor, and update root's node information; or else, pass on the JOIN with the new node's ID to the root's successor.

2) If receives an UPDATE:
   Update predecessor's node information.

3) If receives a CRASH:
   Detect whether the crash node is my successor. If yes, update my successor as the crash node's successor and send REPAIR message to notify it; or else, pass on the CRASH message to my successor.

3. Ping process:

   Ping the node's predecessor every 2 seconds.
   If fails to connect the predecessor, send a CRASH to my successor to repair the ring. 

-------------------------------------------------------------------------------

Main challenges:

1. C programming.
   Proper use of char arrays to store and copy data in memory. When it comes to 
   Memory operations like memory set and memory copy, it is unsafe to use char
   Pointers, which usually lead to memory overflow (error message like segmentation
   fault, core dump, etc.)

2. Thread programming.
   It is my first time to write a thread program. Design which part of the program should go to a single thread is important. I set three threads for peer process, root process and ping process.

3. Organize the program structure.
   I write separate files including a self defined library, mylib.c to make the whole structure clear. I also write many helper functions to tackle the problem piece by piece, making the main function more clear.

-------------------------------------------------------------------------------

Test Strategy:

Define functions to detect errors and print error messages. The program
will terminate after detecting an error.

1. UserErrorMessage()
   Check two types of errors:
   A. illegal format of command to call program, including incorrect number
      of command arguments.
   B. Any operation that breaks the design contract.

2. SystemErrorMessage()
   Check the errors caused by the system operation, including failure of socket
   creation, connection, sending a message, and receiving a message.

3. sha1ErrorMsg()
   Print error message when computing SHA1 and terminate the program.

4. printNode()
   Every time update the local PeerNode, print the node information to make sure the ring is correctly formed.
   
5. Print out the system status whenever necessary.

