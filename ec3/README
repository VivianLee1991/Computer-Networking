
-------------------------------------------------------------------------------

Project3ï¼š

CHORD Distributed Hash Table.

This project is written by Wenwen Li (NEU ID: 001830563) for CS 5700: Fundamentals of Computer Networking.

-------------------------------------------------------------------------------

Achieved functions:

1. DHT Peer
  Implement a dht-peer which interacts with other dht-peers to build a ring.
  Join
  Leave/Crash
  Lookup (both recursive and iterative lookup)
  Print the ring.

2. SHA1 Implementation  Use SHA1 as the consistent hashing function. 
  Compute node ID  : Use IP addresses and port numbers as identiers;
  Compute object ID: Use object file name as the identifier.

3. DHT Client
  Store an object 
  Retrieve an object (recursively and iteratively)
  Menu
  
-------------------------------------------------------------------------------

My submission includes 8 files:

1. makefile
2. README
3. dht_peer.c 
4. dht_peer.h
5. dht_client.c
6. dht_client.h
7. mylib.c
8. mylib.h
9. sha1.c
10. sha1.h

-------------------------------------------------------------------------------

How to run the program:

(On a local host, use different port to allocate different peers.)

1. make
2. Run root: ./dht_peer -m 1 -p 15074 -h localhost
3. Run peer: ./dht_peer -m 0 -p 15070 -h localhost -r 15074 -R localhost
              (In the prompt window, enter '1' to join the peer in the ring.)
4. Exit peer/root: Press control + C
5. Run client: ./dht_client -p 15078 -h localhost -r 15070 -R localhost
6. Exit client: Press 'e' in the menu.

-------------------------------------------------------------------------------

Data definition:

An object of the PeerNode type defines the IP addresses, port numbers, and node IDs for the predecessor node, this node and the successor node.

typedef struct PeerNode {
        // predecessor peer
	unsigned int pre_IP;
	unsigned short pre_Port;
	unsigned short pre_ID;
    
        // this node
	unsigned int cur_IP;
	unsigned short cur_Port;
	unsigned short cur_ID;

	// successor peer
	unsigned int suc_IP;
	unsigned short suc_Port;
	unsigned short suc_ID;
	
} PeerNode;

-------------------------------------------------------------------------------

Message Types:

I. Peer / Root

1. Join Request (to root)
Sender      : a new peer node
Receiver    : the root node
Format      : JOIN + new_IP + new_Port
Message size: 7 bytes.

2. Join Request (to peer)
Sender      : an existing peer node / root
Receiver    : another peer node
Format      : JOIN + new_IP + new_Port + new_ID
Message size: 9 bytes.

3. Join Reply
Sender      : an existing peer node / root
Receiver    : new node
Format      : JOIN_REPLY + new_ID + suc_IP + suc_Port + suc_ID + pre_IP + pre_Port + pre_ID
Message size: 19 bytes.

4. Update
Sender      : an existing peer node / root
Receiver    : an existing peer node / root
Format      : UPDATE_SUC / UPDATE_PRE + IP + Port + ID.
Message size: 9 bytes.

5. Crash
Sender      : an existing peer node / root (first generated by the crash node's successor)
Receiver    : an existing peer node / root
Format      : CRASH + crash_ID + cur_IP + cur_Port + cur_ID
Message size: 11 bytes.

6. Repair (special case of Update)
Sender      : crash node's predecessor
Receiver    : crash node's successor
Format      : UPDATE_PRE + IP + Port + ID.
Message size: 9 bytes.

7. Store Request (to peer)
Sender      : root / peer
Receiver    : peer
Format      : STORE + obj_ID
Message size: 3 bytes.

8. Store Reply
Sender      : root / peer
Receiver    : client / root
Format      : STORE_REPLY + target_ID + target_IP + target_Port
Message size: 9 bytes.

9. Recursive request (to peer)
Sender      : root / peer
Receiver    : peer
Format      : RECURSIVE + obj_ID
Message size: 3 bytes.

10. Recursive Reply
Sender      : root / peer
Receiver    : client / root
Format      : RECUR_REPLY + target_ID + target_IP + target_Port
Message size: 9 bytes.

11. Iterative Reply
Sender      : root / peer
Receiver    : client
Format      : ITERA_REPLY + target_ID + target_IP + target_Port
Message size: 9 bytes.

12. Iterative Next
Sender      : root / peer
Receiver    : client
Format      : ITERA_NEXT + next_ID + next_IP + next_Port
Message size: 9 bytes.


II. Client

1. Store Request
Sender      : client
Receiver    : root
Format      : STORE + obj_ID + client_IP + client_Port
Message size: 9 bytes.

2. Recursive Retrieve
Sender      : client
Receiver    : root
Format      : RECURSIVE + obj_ID + client_IP + client_Port
Message size: 9 bytes.

3. Iterative Retrieve
Sender      : client
Receiver    : root / peer
Format      : ITERATIVE + obj_ID + client_IP + client_Port
Message size: 9 bytes.


III. File Data Transmission

1. Retrieve Message
Sender      : any
Receiver    : any
Format      : RETRIEVE + obj_ID + filename + my_IP + my_Port
Message size: 73 bytes.

2. Data Message
Sender      : any
Receiver    : any
Format      : DATA + my_IP + my_Port + filename + filesize + filedata
Message size: 1500 bytes at most.

3. ACK Message
Sender      : any
Receiver    : any
Format      : ACK
Message size: 1 byte.


-------------------------------------------------------------------------------

Design Approach:

DHT Peer

1. Parse information from the command line.
2. Initialize a receiving socket to receive message from given local port.
   Get local IP address (in bytes) and Port number (in integer).
3. Initialize a mutex for thread programming.
4. Check running mode (input after '-m' on command line).
   If type = 0, run the peer mode, go to step 5;
   If type = 1, run the root mode, go to step 6.
5. Prompt to user, construct a PeerNode to store node information for this node.
   When user enter '1', send a JOIN request to the root.
   Running main process for the node.
6. Compute node ID by SHA1 for the root. 
   Construct a PeerNode to store node information for this root.
   Running main process for the root.

There are two threads in the main process either this node is a peer or a root.
Both root and peer run the same thread to ping it's predecessor node.

1> Peer process:

The peer process keeps receiving messages from other peers or root.

1) If receives a JOIN REPLY:
   Update own node ID, and predecessor's and successor's node information.

2) If receives an UPDATE:
   Update predecessor's or successor's node information.

3) If receives a JOIN:
   Detect whether the node who wants to join the ring is going to be my new successor. If yes, send JOIN REPLY to the new node, send an UPDATE to my successor, and update my successor as the new node; or else, pass on the JOIN to my successor.

4) If receives a CRASH:
   Detect whether the crash node is my successor. If yes, update my successor as the crash node's successor and send REPAIR message to notify it; or else, pass on the CRASH message to my successor.

5) If receives a STORE:
   Detect whether the object should be located on my node. If yes, send a Store Reply back to root; or else, pass on the Store Request to the successor node.

6) If receives a RECURSIVE:
   Detect whether the object should be located on my node. If yes, send a Recursive Reply back to root; or else, pass on the Recursive Retrieve Request to the successor node.

7) If receives a ITERATIVE:
   Detect whether the object should be located on my node. If yes, send a Iterative Reply back to client; or else, send an Iterative Next to the client.

8) If receives a RETRIEVE:
   Send the specified object in the message back to the client.

9) If receives a DATA:
   Store the specified object file date in the message on disk.


2> Root process:

The root process keeps receiving messages from other peers.

1) If receives a JOIN:
   Retrieves the new node's IP, Port number, and accordingly computes its node ID.
   If there is only one node in the ring (i.e. the root), update root's predecessor and successor as the new node, and send JOIN REPLY to the new node.
   Else if there are 2 nodes in the ring, check the new node's position in the ring, send JOIN REPLY to the new node, send UPDATE to root's successor, and update root's node information.
   Else if there are at least 3 nodes in the ring, check whether the new node is root's new successor. If yes, send JOIN REPLY to the new node, send UPDATE to root's successor, and update root's node information; or else, pass on the JOIN with the new node's ID to the root's successor.

2) If receives an UPDATE:
   Update predecessor's node information.

3) If receives a CRASH:
   Detect whether the crash node is my successor. If yes, update my successor as the crash node's successor and send REPAIR message to notify it; or else, pass on the CRASH message to my successor.

4) If receives a STORE:
   Detect whether the object should be located on my node. If yes, send a Store Reply back to client; or else, pass on the Store Request to the successor node.

5) If receives a RECURSIVE:
   Detect whether the object should be located on my node. If yes, send a Recursive Reply back to client; or else, pass on the Recursive Retrieve Request to the successor node.

6) If receives a ITERATIVE:
   Detect whether the object should be located on my node. If yes, send a Iterative Reply back to client; or else, send an Iterative Next to the client.

7) If receives a RETRIEVE:
   Send the specified object in the message back to the client.

8) If receives a DATA:
   Store the specified object file date in the message on disk.



3> Ping process:

   Ping the node's predecessor every 2 seconds.
   If fails to connect the predecessor, send a CRASH to my successor to repair the ring. 



DHT Client

1. Parse information from the command line.
2. Initialize a receiving socket to receive message from given local port.
   Get local IP address (in bytes) and Port number (in integer).
3. Prompt a Menu to the user, continue the process unless user enters 'e' for exit.
4. If 's', 'r', or 'i', prompt user to enter object name and compute objID by SHA1. 

   1> If 's' for storing an object,
      - Send a Store Request message to the root.
      - Wait for receiving a Store Reply from the root.
      - Transmit object file to the target node specified by the reply.
      - If receive back an ACK, prompt success, or else failure.

   2> If 'r' for recursively retrieving an object,
      - Send a Recursive Retrieve message to the root.
      - Wait for receiving a Recursive Reply from the root.
      - Send Retrieve Message to the target node specified by the reply.
      - Wait to receive the Data Message sent from the target node.
      - Send back an ACK message after successfully storing the object.

   3> If 'i' for Iteratively retrieving an object,
      - Send a Iterative Retrieve message to the root.
      - Wait for receiving a Iterative Next/Reply from any node.
      - When received an Iterative Next, send Iterative Retrieve message to the next node.
      - When received an Iterative Reply, send Retrieve Message to the target node specified by the reply.
      - Wait to receive the Data Message sent from the target node.
      - Send back an ACK message after successfully storing the object.

-------------------------------------------------------------------------------

Main challenges:

1. C programming.
   Proper use of char arrays to store and copy data in memory. When it comes to 
   Memory operations like memory set and memory copy, it is unsafe to use char
   Pointers, which usually lead to memory overflow (error message like segmentation
   fault, core dump, etc.)

2. Thread programming.
   It is my first time to write a thread program. Design which part of the program should go to a single thread is important. I set three threads for peer process, root process and ping process.

3. Organize the program structure.
   I write separate files including a self defined library, mylib.c to make the whole structure clear. I also write many helper functions to tackle the problem piece by piece, making the main function more clear.

-------------------------------------------------------------------------------

Test Strategy:

Define functions to detect errors and print error messages. The program
will terminate after detecting an error.

1. UserErrorMessage()
   Check two types of errors:
   A. illegal format of command to call program, including incorrect number
      of command arguments.
   B. Any operation that breaks the design contract.

2. SystemErrorMessage()
   Check the errors caused by the system operation, including failure of socket
   creation, connection, sending a message, and receiving a message.

3. sha1ErrorMsg()
   Print error message when computing SHA1 and terminate the program.

4. printNode()
   Every time update the local PeerNode, print the node information to make sure the ring is correctly formed.
   
5. Print out the system status whenever necessary.

